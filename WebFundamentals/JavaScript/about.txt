WEB FUNDAMENTALS 
JAVASCRIPT
console.dir(document);
https://repl.it/

$(document).on("click",".alert", function(){alert("alert");});
---
function attach_handlers(){
	$(".alert").click(function(){alert("clicked!");});
};
$(document).ready(function(){
	attach_handlers();
	$(".new_button").click(function(){
		$("#buttons").append("<button class='alert'>dynamically generate button</button>");
		attach_handlers();
	});
});
---

traverse: parent and siblings

Cool jQuery Plugins
Below are some cool jQuery Plugins you can get familiar with.

It's important to only spend up to 30 minutes reviewing the tools below. You can always come back and learn more about these tools when you need them. We basically don't want you to spend too much time looking into these tools as there are lots of things we want to cover next.

Tablesorter
A jQuery Plugin that allows you to sort table data. It's an awesome tool!
http://tablesorter.com/docs/
Tipped
Tipped allows you to easily create beautiful tooltips using the jQuery Javascript library.
http://projects.nickstakenburg.com/tipped
Tipsy
Another tooltip plugin that imitates the Facebook tooltip using CSS and jQuery.
http://onehackoranother.com/projects/jquery/tipsy/

Debugging Your JavaScript Code
This is an extremely important topic, so repeat these steps until you understand them well. 
There are various ways to test and debug your JavaScript code, using artificial environments such as JSbin or plugins for your code editor. 
However, we prefer to use the real-world JavaScript environment that truly matters — the browsers'. 
This way, you can use all the features of your development environment, and test your code in a way that doesn’t just emulate the real-world environment: 
it is the real-world environment. Here are steps for one possible way to create/test your code in this manner:
1  Go to Sublime/Atom, create a new file with the HTML file extension, and save it.
2  Within that file, type html and hit [tab]. Sublime/Atom will create the basic HTML tags for you.
3  Within the <head> section, type script and again hit [tab], to create <script> tags. 
   You can delete the other attributes inside the <script> tag, as well as the <style> and even <body> tags; 
   you don’t need those if all you are doing is writing/testing JavaScript.
4  As the very first line after the <script> tag, always include "use strict"; (including the semicolon).
5  Now write your JS code as you wish. Remember to save as you go, of course.
6  When you are ready to test your code (which should be early and often), right-click on the Sublime/Atom file and select “Open in Browser”.
7  Your default browser will open a window. We prefer Chrome for testing JS, but any browser is fine. 
   Within that window, open the Developer Console (the MacOS key sequence is cmd-opt-J).
8  Type JS into the console such as returnGreaterThanSecond([1,3,5,7,9,11,15]) or var arr=[];returnGreaterThanSecond(arr) or printOdds() to exercise your code.
9  To change or add to your code, cmd-tab back to Sublime/Atom, make your change, then Save.
10 Switch back to browser and Refresh, returning to step 8. 
You will soon memorize the quick-key sequence for saving in Sublime/Atom, returning to the browser and refreshing (cmd-s, cmd-tab, cmd-r).
Ultimately, your JavaScript code will run in the browser JS runtime environment, rather than an artificial environment such as JSbin. 
They produce slightly different results sometimes, so why bother?

'Truthy' and 'Falsey'
JavaScript is well-known for its ‘loose’ treatment of data types. 
In actuality, JavaScript considers almost everything an object, since almost every possible value has a set of methods attached (valueOf, toString, etc). 
That said, typeof returns six possible values, suggesting that there are six top-level data types: boolean, number, string, object, function, and undefined. 
(A seventh, introduced in ES6, is left as an exercise for the reader.) JavaScript converts values between data types, as needed. 
For example, if() converts a value to a boolean, to decide which way to branch.
Most values are considered something, and if converted to a boolean they equate to true. 
Only six values are considered nothing: false, 0, NaN, "", null, undefined; these six are “falsey” because when converted to a boolean, they equate to false. 
All other values are “truthy”, including all objects, functions, non-0 numbers (e.g.: -Infinity), and non-empty strings (including "0" and "false"). 
In your conditional statements, you might combine values by using operators such as + or / or && or ||.  
Note that these operators do not automatically convert a value to a boolean, 
although after using these operators you might commonly convert the result to a boolean. 
From what you have learned so far, only the following will automatically convert a value to a boolean: 
1) the comparison operators (>, <, >=, <=, ==, ===), 
2) the negation ( ! ) operator, and 
3) the input to if( ) and while( )  (as well as the second of the three inputs to a for( ) loop). 

The Document Object Model
When an HTML (or XML) file is interpreted by a browser, 
it also generates what we call the Document Object Model (DOM) – a representation of the entire web page as objects. 
We can manipulate these objects with JavaScript.
W3 Schools has a list of some of the methods and properties of an HTML document: http://www.w3schools.com/jsref/dom_obj_document.asp
You can think of the document as a big container, inside of which sits information (properties) and instructions (methods). 
You can access these objects – for example, the body – by calling  document.bodyin the console. 
In other instances, fetching the object requires you to use a built-in method such as getElementsByTagName ( e.g. document.getElementsByTagName('div')). 
This will return an array of DOM elements.
Each specific element also has a  wealth of methods to exploit.
Open up Chrome and a JavaScript console. Let’s play with the DOM a little bit:

Try this in the console:
console.log(document.body);
Next, try this:

var body = document.body;
// this is more fun if it's a random page with stuff already on it (like the learning platform for example).
body. innerHTML = "Hello World";
Awesome ---- we are manipulating the DOM using JavaScript. Good work!

Let’s try this:

var bod = document.body;
for (var i = 0; i < 10; i ++){
  bod. innerHTML += "<p>This has gone through the loop completely: " +i+ " times</p>";
}
Lastly, these DOM elements can listen for events. After we’ve placed all the p-tags into the body (using the above loop), 
let’s put an event listener on them!

var paragraphs = document.getElementsByTagName('p');
console.log(paragraphs);
for (var i = 0; i < paragraphs.length; i ++){
  console.log(paragraphs[i].addEventListener);
  paragraphs[i].addEventListener('click', function(){
    this.style.background='blue';
  });
}
Unfortunately, that was a bit tedious (the interface to access and manipulate the DOM is widely viewed as clunky), 
and it'd be great if there was a more streamlined way to get the job done (more on this later).

This is exactly where front-end frameworks or libraries come in handy. 
By layering some functionality atop regular JavaScript, the DOM becomes much easier to manipulate. 
That means faster development and, hopefully, a better end product. In the MEAN stack, we'll learn about one of these: AngularJS. 
But before that, let's play with jQuery.

Using .on()

The most effective way to add event handlers to any dynamically rendered HTML content is to use the .on() method. The .on() method works a little differently than the jQuery commands you have practiced up to this point. So how does .on() work? We must attach the .on() function to something within a selector. However, what you pass into the selector is not what you want to attach the event to. What goes into the selector is the element that contains the relevant HTML element(s) you want to attach an event listener to. You can think of the element you select as the sphere of detection for the event you want to listen for.  

Here's an example:

$(document).on('click', 'button', function(){alert('you clicked a button!')});
So, the 'sphere of detection' of this instance of .on() is paired with the selector for the whole document. That means that the following parameters of the function will be applied to everything contained in the entire document. This is the widest scope that you can use on a jQuery function. If you want your scope to be smaller, you can select a different element in the selector.

The .on() function takes up to 4 parameters and we will show you how they mesh with our example above:

The event: Are you waiting for a click? A submit? Keydown? In this case, we are looking for a click.
Data you wish to pass to the handler (this is not required and seldom used). We're not using it here!
The target: i.e. the element you are trying to target. Here we are targeting a button. So now our search is narrowed down listening for a button to be clicked.
The function you want to run: Just the stuff you want to attach! In our case, we are just going to alert to the screen that we clicked a button-- every time a button is clicked.
Every time the event you specified in the first item (1) happens, the function searches the document for the target(s) you specified in the third item (3). If the action was triggered by the correct element, the code you put in the fourth item (along with any information you passed from the optional second item) will be executed.

The really neat thing about this .on() function is that every time the event happens in the corresponding target, the relevant parts of the document get scanned in real time. Thus, any new element added after page load will be detected and the code will run. Pretty great, huh? Using this method, the code we need to accomplish the same goal as the previous tab would be the following:

 $(document).ready(function(){
     $('button').click(function(){
         $('div').append('<h3>I am a dynamically generated h3 </h3>');
      });
     $(document).on('click', 'h3', function(){
         alert('You clicked me!');
     })
 });
Scope
Since we first must assign the scope of where our .on() function will look, this invites a question: why not just always use document? Using $(document).on() will assure us that no item can accidentally pass through detection. Well, think about it like this: if we tell you that one of your friends has a message for you, but you must figure out which friend has it -- that might take a while to figure out.  If, instead, we say: one of your friends who lives on a particular street in Mountain View has a message for you -- that would take a lot less time. Same concept with being more specific in your selector for the .on() method; the more searching of the document the .on() function has to do, the slower your code will run. Selecting $(document) for everything in an average website won't slow down your performance at all, but if you have tens of thousands of dynamic HTML elements that you are trying to add handlers to, using a more specific selector can make a huge difference between your website crashing or working. This will apply to anyone interested in game development, where thousands of operations per second are the norm.

Also, another great reason to judge the scope of your detection carefully is that you may not want all dynamic HTML elements to have the same functionality. Consider the following code:

 <script>
  $(document).ready(function(){
   $('button').click(function(){
    $('div').append('<h3>I am a new content</h3>');
   });
   $(document).on('mouseover', 'h3', function(){
    $(this).css('color', 'pink');
   });
  });
 </script>
 <body>
  <button>Click me for new content!</button>
  <div class='a'>
   <h3>I am old content</h3>
  </div>
  <div class='b'>
   <h3>I am old content</h3>
  </div>
 </body>
Note: for this function, 'mouseover' takes the place of 'hover'.

If you run the code, you will notice that both divs will have dynamic content generated when the button is clicked. When any h3 on the page is hovered over, it will turn pink. Perhaps you want to change the functionality a little bit so that only the divs in the class 'a' div have this functionality. We can make this change quite easily using the selector correctly. Observe:

<script>
  $(document).ready(function(){
   $('button').click(function(){
    $('div').append('<h3>I am a new content</h3>');
   });
   $('div.a').on('mouseover', 'h3', function(){ 
    $(this).css('color', 'pink');
   });
  });
</script>
<body>
  <button>Click me</button>
  <div class="a">
   <h3>I am old content</h3>
  </div>
  <div class="b">
   <h3>I am old content</h3>
  </div>
</body>
